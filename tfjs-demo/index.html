<html>
<head>

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
  
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">
  <link rel="stylesheet" href="./style.css">

  <script src="https://d3js.org/d3.v5.min.js"></script>
  <!-- <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.11.6"> </script> -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min.js"></script>
  <script>
  d3.selection.prototype.moveToFront = function() {
    return this.each(function(){
    this.parentNode.appendChild(this);
    });
  };
  </script>
</head>

<body>
<svg id='loss' width=100 height=100></svg>
<svg id='graph' width=100 height=100></svg>
<i id='play' class="fas fa-pause-circle"></i>
<!-- <i class="fas fa-pause-circle"></i> -->
<i id='reset' class="fas fa-random"></i>

<div class='form-group'>
  <label for='graphType'>Graph Type:</label>
  <select id="graphType" class="form-control" style='width: 150px;'>
    <option value="simple-4">simple-4</option>
    <option value="cycle-10">cycle-10</option>
    <option value="tree-2-3" >tree-2-3</option>
    <option value="tree-2-4">tree-2-4</option>
    <option value="tree-2-5">tree-2-5</option>
    <option value="cube">cube</option>
    <option value="dodecahedron" selected>dodecahedron</option>
  </select>
</div>

<div>
  <span>Stress </span><span id='coefText1'></span>
  <input id='coef' class='slider' type="range" min=0 max=100 value=0>
  <span>Angle </span><span id='coefText2'></span>
</div>

<div>
  <span>LR: </span>
  <input id='lr' class='slider' type="range" min="0" max="10" value="7" step="0.1">
  <span id='lrText'></span>
</div>

<div>
  <p id='caption'></p>
</div>


<script>

function randInt(a,b){
  return parseInt(Math.random() * (b-a) + a);
}


function pairwise_distance(x){
  return tf.tidy(()=>{
    let xNormSquared = x.norm('euclidean', 1, true).pow(2);
    let pairwiseDotProduct = x.matMul(x.transpose());
    let pdistSqaured = pairwiseDotProduct.mul(-2)
    .add(xNormSquared)
    .add(xNormSquared.transpose());
    let pdist = pdistSqaured.clipByValue(0, Infinity).sqrt();
    return pdist;
  });
}


function stress_loss(pred, target, weight){
  return tf.tidy(()=>{
    return pred.sub(target).square().mul(weight).mean();
  });
}


// function angle_loss_e1e2(x, e1, e2){
//   let [i,j] = e1;
//   let [k,l] = e2;
//   return tf.tidy(()=>{
//     let p1 = x.gather(i, 0);
//     let p2 = x.gather(j, 0);
//     let p3 = x.gather(k, 0);
//     let p4 = x.gather(l, 0);
//     let e1 = p2.sub(p1);
//     let e2 = p4.sub(p3);
//     let dot = e1.dot(e2);
//     let norm1 = e1.norm();
//     let norm2 = e2.norm();
//     let cos = dot.div(norm1.mul(norm2));
//     return cos.abs();
//   });
// }


function sign(p, line){
  let s = (p.x-line[0].x)*(line[1].y-line[0].y) + (p.y-line[0].y)*(line[0].x-line[1].x);
  if(s>0){
    return 1;
  }else if(s==0){
    return 0;
  }else{
    return -1;
  }
}


function isSameSide(p1, p2, line){
  let s1 = sign(p1, line);
  let s2 = sign(p2, line);
  return s1 * s2;
}


function hasCrossing(nodes, includeEndpoints=false){
  let [n1,n2,n3,n4] = nodes;
  let ss1 = isSameSide(n1, n2, [n3, n4]);
  let ss2 = isSameSide(n3, n4, [n1, n2]);
  if (includeEndpoints){
    return ss1<=0 && ss2 <= 0;
  }else{
    return ss1<0 && ss2 < 0;
  }
}


function dot(x, y){
  let dim = 1;
  let keepDims=true;
  return tf.tidy(()=>{
    return x.mul(y).sum(dim, keepDims);
  });
}


function cosSimilarity(x, y){
  let dim = 1;
  let keepDims = true;
  return tf.tidy(()=>{
    let xNorm = x.norm('euclidean', dim, keepDims);
    let yNorm = y.norm('euclidean', dim, keepDims);
    let cos = dot(x,y).div(xNorm.mul(yNorm));
    return cos
  });
}


function angle_loss(x, graph, sampleSize=1){
  let crossings = [];

  for (let e1 of graph.edges){
    for (let e2 of graph.edges){
      let i = e1.source.index;
      let j = e1.target.index;
      let k = e2.source.index;
      let l = e2.target.index;
      let nodes = [graph.nodes[i], graph.nodes[j], graph.nodes[k], graph.nodes[l]];
      let crossed = hasCrossing(nodes);
      if (crossed){
        crossings.push([[i,j],[k,l]]);
      }
    }
  }

  // // let sampleSize = crossings.length;
  // // let sampleSize = Math.min(5, Math.ceil(crossings.length)/2);
  // let sampleSize = 1;
  let sampledCrossings = _.sample(crossings, sampleSize);
  if(sampledCrossings.length > 0){
    return tf.tidy(()=>{
      let p1 = x.gather( sampledCrossings.map(d=>d[0][0]) );
      let p2 = x.gather( sampledCrossings.map(d=>d[0][1]) );
      let p3 = x.gather( sampledCrossings.map(d=>d[1][0]) );
      let p4 = x.gather( sampledCrossings.map(d=>d[1][1]) );
      let e1 = p2.sub(p1);
      let e2 = p4.sub(p3);
      let cos = cosSimilarity(e1, e2);
      return cos.square().mean();
    });
  }else{
    return tf.scalar(0.0);
  }
  
}

function trainOneIter(dataObj, optimizer){
  let x = dataObj.x;
  let graphDistance = dataObj.graphDistance;
  let stressWeight = dataObj.stressWeight
  let graph = dataObj.graph;
  let coef = dataObj.coef;
  return optimizer.minimize(()=>{
    console.log(optimizer.learningRate);
    let pdist = pairwise_distance(x);
    let l = tf.tidy(()=>{
      let st = stress_loss(pdist, graphDistance, stressWeight);
      let an = angle_loss(x, graph, dataObj.sampleSize || 1);
      return st.mul(coef.stress).add(an.mul(coef.angle));
    });
    return l;
  }, true);
}


function train(dataObj, remainingIter, optimizers, callback){
  let loss_i = trainOneIter(dataObj, optimizers[0]).dataSync()[0];
  if (callback){
    callback({
      remainingIter,
      loss: loss_i,
    });
  }
  if (remainingIter <= 0 || !isPlaying){
    cancelAnimationFrame(dataObj.animId);
    console.log('Max iteration reached, please double click the play button to restart');
  }else{
    dataObj.animId = requestAnimationFrame(()=>{
      train(dataObj, remainingIter-1, optimizers, callback);
    });
  }
}


function updateAxes(svg, sx, sy){
  let ax = d3.axisBottom(sx)
  .tickSizeInner(-(sy.range()[0]- sy.range()[1]));
  let ay = d3.axisLeft(sy)
  .tickSizeInner(-(sx.range()[1]- sx.range()[0]));
  let gx = svg.selectAll('.xAxis')
  .data([0,])
  .enter()
  .append('g')
  .attr('class', 'xAxis');
  gx = svg.selectAll('.xAxis')
  .attr('transform', `translate(${0},${sy.range()[0]})`)
  .call(ax);
  let gy = svg.selectAll('.yAxis')
  .data([0,])
  .enter()
  .append('g')
  .attr('class', 'yAxis');
  gy = svg.selectAll('.yAxis')
  .attr('transform', `translate(${sx.range()[0]},${0})`)
  .call(ay);
}

function traceLoss(svg, losses, maxPlotIter){
  let sx = d3.scaleLinear();
  let sy = d3.scaleLinear();

  function updateScales(){
    let width = svg.node().clientWidth;
    let height = svg.node().clientHeight;
    sx.domain([0, maxPlotIter])
    .range([40, width-20]);
    sy.domain(d3.extent(losses))
    .range([height-30,20]);
  }

  

  function draw(){
    svg.selectAll('#lossCurve')
    .data([losses])
    .enter()
    .append('path')
    .attr('id', 'lossCurve');
    let lossCurve = svg.select('#lossCurve');

    lossCurve
    .attr('fill', 'none')
    .attr('stroke', d3.schemeCategory10[0])
    .attr('stroke-width', 1.5)
    .attr('d', d3.line()
      .curve(d3.curveLinear)
      .x((d,i)=>sx(i))
      .y((d)=>sy(d))
    );
  }

  window.addEventListener('resize', ()=>{
    updateScales();
    updateAxes(svg, sx, sy);
    draw();
  });
  updateScales();
  updateAxes(svg, sx, sy);
  draw();
}//traceLoss end


function preprocess(graph, initPos){
  graph.nodes.forEach((d,i)=>{
    d.x = initPos[i][0];
    d.y = initPos[i][1];
  });

  graph.edges.forEach((d,i)=>{
    d.source = graph.nodes.filter(e=>e.id==d.source)[0];
    d.target = graph.nodes.filter(e=>e.id==d.target)[0];
  });
}


function updateNodePosition(graph, xy){
  graph.nodes.forEach((d,i)=>{
    d.x = xy[i][0];
    d.y = xy[i][1];
  });
}


function drawGraph(svg, graph){
  if(svg.sx == undefined){
    svg.sx = d3.scaleLinear();
    svg.sy = d3.scaleLinear();
  }

  function updateScales(){
    let width = svg.node().clientWidth;
    let height = svg.node().clientHeight;

    let xExtent = d3.extent(graph.nodes, d=>d.x);
    let yExtent = d3.extent(graph.nodes, d=>d.y);
    
    if (svg.xDomain !== undefined){
      svg.xDomain[0] = Math.min(xExtent[0], svg.xDomain[0]);
      svg.xDomain[1] = Math.max(xExtent[1], svg.xDomain[1]);
      svg.yDomain[0] = Math.min(yExtent[0], svg.yDomain[0]);
      svg.yDomain[1] = Math.max(yExtent[1], svg.yDomain[1]);
    }else{
      svg.xDomain = xExtent;
      svg.yDomain = yExtent;
    }
    xExtent = svg.xDomain.slice(0);
    yExtent = svg.yDomain.slice(0);
    let xSize = xExtent[1] - xExtent[0];
    let ySize = yExtent[1] - yExtent[0];

    let xViewport = [30, width-20];
    let yViewport = [height-20,20];
    let drawWidth = xViewport[1] - xViewport[0];
    let drawHeight = yViewport[0] - yViewport[1];

    if (drawWidth/drawHeight > xSize/ySize){
      let adjust = (ySize / drawHeight * drawWidth) - xSize;
      xExtent[0] -= adjust/2;
      xExtent[1] += adjust/2;
    }else{
      let adjust = (xSize / drawWidth * drawHeight) - ySize;
      yExtent[0] -= adjust/2;
      yExtent[1] += adjust/2;
    }
    
    svg.sx.domain(xExtent)
    .range(xViewport);
    svg.sy.domain(yExtent)
    .range(yViewport);

    // svg.sx.domain([-7,7])
    // .range(xViewport);
    // svg.sy.domain([-7,7])
    // .range(yViewport);

  }
  
  function draw(){
    svg.selectAll('.edge')
    .data(graph.edges)
    .exit()
    .remove();
    let edges = svg.selectAll('.edge')
    .data(graph.edges)
    .enter()
    .append('line')
    .attr('class', 'edge')
    .attr('fill', 'none')
    .attr('stroke', '#333')
    .attr('stroke-width', 2)
    .attr('opacity', 0.8);
    edges = svg.selectAll('.edge')
    .attr('x1', d=>svg.sx(d.source.x))
    .attr('x2', d=>svg.sx(d.target.x))
    .attr('y1', d=>svg.sy(d.source.y))
    .attr('y2', d=>svg.sy(d.target.y));

    svg.selectAll('.node')
    .data(graph.nodes)
    .exit()
    .remove();
    let newNodes = svg.selectAll('.node')
    .data(graph.nodes)
    .enter()
    .append('g')
    .attr('class', 'node');

    let newCircles = newNodes
    .append('circle')
    .attr('r', 12)
    .attr('fill', d3.schemeCategory10[0]);

    let newTexts = newNodes
    .append('text')
    .style('font-size', 12)
    .style('fill', '#eee')
    .style('text-anchor', 'middle')
    .style('alignment-baseline', 'middle');

    let nodes = svg.selectAll('.node')
    .attr('transform', d=>`translate(${svg.sx(d.x)},${svg.sy(d.y)})`)
    .moveToFront();
    let texts = nodes.selectAll('text')
    .text(d=>d.id);
    let circles = nodes.selectAll('.circles');
  }

  window.addEventListener('resize', ()=>{
    updateScales();
    updateAxes(svg, svg.sx, svg.sy);
    draw();
  });

  updateScales();
  updateAxes(svg, svg.sx, svg.sy);
  draw();
}//drawGraph end


function updateSvgSize(svg_loss, svg_graph){
  let width =  window.innerWidth/2-20;
  let height =  window.innerHeight-250;
  svg_loss
  .attr('width', width)
  .attr('height', height);
  svg_graph
  .attr('width', width)
  .attr('height', height);
}

function getCoef(value){
  let sStress = d3.scaleLinear()
  .domain([0,100])
  .range([1,0]);
  let sAngle = d3.scaleLinear()
  .domain([0,100])
  .range([0,0.1]);

  return {
    stress: sStress(value),
    angle: sAngle(value),
  };

}
// main
let isPlaying = true;
window.onload = function(){
  let graphTypeSelect = d3.select('#graphType');
  let fn = `data/${graphTypeSelect.node().value}.json`;

  let lrSlider = d3.select('#lr');
  let lr = lrSlider.node().value;
  let lrText = d3.select('#lrText')
  .text(lr);

  let coefSlider = d3.select('#coef');
  let coefText1 = d3.select('#coefText1');
  let coefText2 = d3.select('#coefText2');
  let coefSliderValue = coefSlider.node().value;
  let coef = getCoef(coefSliderValue);

  let sampleSize = 2;
 

  let maxPlotIter = 500;
  let niter = 1000;
  let optimizers = [tf.train.sgd(lr)];
  window.optimizers = optimizers;
  let losses = [];
  let animId = 0;

  let svg_loss = d3.select('#loss');
  let svg_graph = d3.select('#graph');

  let playButton = d3.select('#play');
  let resetButton = d3.select('#reset');

  

  updateSvgSize(svg_loss, svg_graph);
  window.addEventListener('resize', ()=>{updateSvgSize(svg_loss, svg_graph)});

  function loadGraph(fn){
    d3.json(fn).then((graph)=>{
      let x;
      function reset(){
        x = tf.variable(tf.randomUniform([graph.nodes.length,2]));
      }

      if(graph.initPositions){
        x = tf.variable(tf.tensor2d(graph.initPositions));
      }else{
        reset();
      }

      preprocess(graph, x.arraySync());

      let graphDistance = tf.tensor2d(graph.graphDistance);
      let stressWeight = tf.tensor2d(graph.weight);

      let dataObj = {
        sampleSize,
        x, 
        graphDistance, 
        stressWeight,
        graph,
        animId,
        coef,
      };
      window.dataObj = dataObj;

      function play(){
        train(dataObj, niter, optimizers, (record)=>{
          // console.log(record);
          losses.push(record.loss);
          if (losses.length>maxPlotIter){
            losses = losses.slice(1);
          }
          traceLoss(svg_loss, losses, maxPlotIter);
          updateNodePosition(graph, x.arraySync());
          drawGraph(svg_graph, graph);
        });
      }
      play();
      
      //interactions
      playButton.on('click', function(shouldPlay){
        if(shouldPlay === undefined){
          isPlaying = !isPlaying;
        }else{
          isPlaying = shouldPlay;
        }
        if(isPlaying){
          d3.select(this).attr('class', 'fas fa-pause-circle');
          play();
        }else{
          d3.select(this).attr('class', 'fas fa-play-circle');
        }
      });

      resetButton.on('click', function(){
        reset();
        svg_graph.xDomain = undefined;
        let xy = x.arraySync();
        graph.nodes.forEach((d,i)=>{
          d.x = xy[i][0];
          d.x = xy[i][1];
        });
        dataObj.x = x;
        drawGraph(svg_graph, graph);
      });

      graphTypeSelect.on('change', function(){
        let fn = d3.select(this).node().value;
        fn = `data/${fn}.json`;
        cancelAnimationFrame(dataObj.animId);
        loadGraph(fn);
      });

      lrSlider.on('input', function(){
        let lr = d3.select(this).node().value;
        lrText.text(lr);
        optimizers[0] = tf.train.sgd(lr);
        // optimizer.learningRate = ;
      });

      coefSlider.on('input', function(){
        let coefSliderValue = coefSlider.node().value;
        let newCoef = getCoef(coefSliderValue);
        coefText1.text((newCoef.stress).toFixed(2));
        coefText2.text((newCoef.angle).toFixed(3));
        for(let key in newCoef){
          coef[key] = newCoef[key];
        }
      });
      coefSlider.on('input')();


    });
  }//loadGraph end
  loadGraph(fn);



};//onload end
</script>
</body>
</html>